var minMalwareSpread = function(graph, initial) {
	var N = graph.length;
	var parent = new Array(N).fill(-1);
	initial.sort((a,b) => a-b);
//	console.log(initial);
	var set = new Set();
	for (let n of initial) set.add(n);
	
	for(let i=0;i<N;i++){
		if(set.has(i)) continue;
		for (let j = 0; j < N; j++){
			if(set.has(j)) continue;
			if (graph[i][j] == 1) {
				union(i,j,parent);
			}
		}
	}
	
	var total = Number.MAX_VALUE;
	var res = -1;
	for (let skip = 0; skip < initial.length; skip++){
		var counts = new Map();
		for (let mal = 0; mal < initial.length; mal++) {
			if (mal == skip) continue;
			var malId = initial[mal];
			for (let i = 0; i < N; i++) {
				if (i == initial[skip]) continue;
				if (graph[malId][i] == 1) {
					var root = find(i, parent);
					if(!counts.has(root)){
						counts.set(root, -parent[root]);
					}
				}
			}
		}
		var sum = 0;
		console.log("Counts ", counts);
		
		for (let [k, v] of counts) {
			console.log("Here....",v);
	        sum += v;
	    }
		if (sum < total) {
	        total = sum;
	        res = initial[skip];
 
		}
	
 
    }
	return res;
};

function find(x,parent) {
    if (parent[x] < 0) return x;
    parent[x] = find(parent[x], parent);
    return parent[x];
}

function union(x,y,parent){
	x = find(x,parent);
	y = find(y,parent);
	if (x == y) return;
	if (parent[x] <= parent[y]) {
		parent[x] += parent[y];
		parent[y] = x;
	}else{
		parent[y] += parent[x];
		parent[x] = y;
	}
}
var graph1 = [[1,1,0],[1,1,0],[0,0,1]], initial1 = [0,1]
var graph2 = [[1,1,0],[1,1,1],[0,1,1]], initial2 = [0,1];

console.log("Ans: ",minMalwareSpread(graph1,initial1));
console.log("Ans: ",minMalwareSpread(graph2,initial2));

//Another approach:
//	https://leetcode.com/problems/minimize-malware-spread-ii/discuss/184645/Straightforward-DFS-Java-6-ms